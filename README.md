# Yus.rs – Full-Stack Rust Web Application for Performance and Reliability

**Yus.rs** is a personal full-stack web application built entirely in Rust, showcasing systems-level engineering applied to modern web development. It serves as both an interactive portfolio website and a technology demo that highlights the creator’s proficiency in backend and systems programming. Yus.rs delivers a fast and safe user experience by combining a WebAssembly front-end with a high-performance Rust backend, demonstrating how Rust’s performance and reliability can elevate web architecture.

## Project Overview

Yus.rs was designed to **push the boundaries of web performance and safety**. The project consists of a single-page application written in Rust (compiled to WebAssembly) and a robust Actix Web server on the backend. The site features an interactive 3D graphics demo (rendered with WebGPU or WebGL2 if WebGPU is not available) alongside dynamic content like project listings fetched in real-time from GitHub. By unifying the front-end and back-end in one language (Rust), Yus.rs ensures end-to-end type safety, memory safety, and consistent design principles across the stack. This project not only acts as a personal website but also as a proof-of-concept that complex web apps can be built with the reliability of systems-level code.

## Key Features

- **Full Rust Front-End (WASM):** The front-end is written in Rust using the Leptos framework, then compiled to WebAssembly. This means no traditional JavaScript framework – instead, Rust’s **performance and type safety** drive the interactive UI. The site loads a WebAssembly package for a rich client experience, demonstrating an ability to leverage cutting-edge web tech for maximum speed and safety.

- **Interactive WebGPU Graphics:** Yus.rs features eye-catching 2D and 3D visualizations powered by WebGPU/WebGL2 (via Rust’s `wgpu` library). This real-time graphics demo runs in the browser with near-native performance, showcasing comfort with low-level graphics programming. It’s not just flashy; it’s a test of Rust’s systems capabilities on the web, executed safely within a sandboxed environment.

- **Live Integration with External APIs:** The site pulls data about projects directly from GitHub using GraphQL. Project listings (name, description, tech stack, last update status) are fetched on-demand via the backend service. This highlights **architectural design**: Yus.rs acts as a middleware between GitHub’s API and the front-end, aggregating and caching results. The implementation emphasizes reliability; network calls are cached for efficiency and any failures are handled gracefully to keep the site responsive.

- **Safety and Reliability by Design:** By using Rust throughout, Yus.rs benefits from memory safety and thread safety guarantees, eliminating entire classes of runtime bugs (no null pointers, no data races). The backend has strong error handling (using Rust’s `Result` types and error propagation) to gracefully handle edge cases. The system uses typed structures for data (e.g., deserializing GitHub responses into Rust types) ensuring that inconsistent or unexpected data is caught early. These choices result in a service that can run continuously without leaks or crashes – a reliability critical for production systems.

## Architecture and Technical Highlights

**Separation of Concerns:** The project is organized as a Cargo workspace with separate crates for the client (`ui`) and server (`site`). This modular structure mirrors a professional architecture; each part is cohesive and focused. The front-end crate manages UI components, routes, and the WebGPU renderer, while the back-end crate handles web routing, API calls, and serving static files. This separation makes the codebase easier to maintain and extend, as evidenced by the clean interface between front-end and back-end (communicating over HTTP/JSON).

**Front-End (Leptos + WebAssembly):** The Leptos framework enables a reactive single-page app structure in Rust. UI components are defined in Rust, and Leptos handles efficient DOM updates. This means the developer can use compile-time checks and Rust’s rich type system even for front-end logic. The integration of the WebGPU-powered canvas into this framework is a standout aspect, rendering code runs in a `web_sys` context to draw interactive graphics, while Leptos reactivity can overlay UI controls or respond to user input. The result is a smooth animation and interaction, achieved without sacrificing safety (no unsafe needed for graphics calls, leveraging the `wgpu` abstraction and Rust’s borrow checker to manage GPU resources correctly).

**Back-End (Actix Web Service):** On the server side, Actix Web provides a powerful, industrial-grade framework. The back-end of Yus.rs is asynchronous from the ground up; queries to GitHub, file reads, and network writes all happen without blocking the main thread. Actix spawns a thread pool to handle requests concurrently, which is ideal for a high-throughput scenario like serving many static files (the WASM bundle, assets) while also handling API requests. The routing is simple and effective: a single page application needs only one HTML entry point (served at `/`) and a few static file routes, plus the dynamic `/api/projects`. The server is configured to serve the compiled WASM and other static assets directly from memory/disk, and uses an SPA fallback (unrecognized routes all return `index.html`) to support client-side routing without server errors. This reflects a production-ready setup for modern web apps.

**Performance Optimizations:** Yus.rs employs multiple layers of caching and optimization:

- The GitHub project data is cached in-memory (with an eviction policy) to avoid rate limits or unnecessary latency on repeated visits. This cache is a thread-safe, asynchronous cache (using the `moka` crate) that ensures even under load the external API isn’t a bottleneck.
- The WebAssembly front-end means that a lot of work is done client-side at native speed. Complex rendering computations or data filtering can run in the browser’s WebAssembly VM, reducing server load and latency.
- On the server, using a compiled language and asynchronous runtime gives predictable low latency. The project uses release-mode builds and is deployed as an optimized binary, so it starts up quickly and runs with minimal overhead (no interpreter, garbage collector pauses, etc.).
- Even the deployment config targets performance: the app runs in a lightweight container and is deployed on a low-latency global platform (Fly.io), meaning it’s accessible quickly from different regions. Envoy proxies or Fly’s global networking ensure fast content delivery to end users.

**Robust DevOps and Maintainability:** Although Yus.rs is a personal project, it’s approached with the rigor of a production service:

- **Continuous Deployment:** Changes to the code repository trigger an automated deployment pipeline. Docker images are built and pushed on each commit, and the app is continuously deployed to Fly.io. This pipeline uses caching strategies (caching Rust build artifacts) to speed up builds, reflecting an understanding of CI/CD optimization.
- **Infrastructure as Code:** Config files like `fly.toml` and Dockerfile are part of the repo. The Dockerfile uses a multi-stage build to produce a slim runtime image with only the necessary binaries and assets. It also runs the service as a non-root user, mirroring best practices in containerized app deployment. These choices demonstrate foresight about security and environment parity; the same container can run locally or in cloud with confidence.

## Why It Matters

Yus.rs matters in two ways: **as a demonstration of technology** and **as evidence of engineering philosophy**. Technologically, it proves that a single language (Rust) can seamlessly handle what traditionally requires multiple stacks (frontend JavaScript, backend Python/Node/Go, etc.). This means fewer context switches for a developer and consistent performance and safety guarantees. For a hiring manager, this signals a developer who is versatile and not afraid to venture beyond the ordinary to achieve better results.

On a higher level, the project reflects an engineering philosophy of *building things the right way*. Instead of a quick-and-easy personal homepage using a template, Yus.rs was carefully crafted to be **novel, efficient, and robust**. The choice to include a WebGPU graphics demos, for instance, wasn’t just to show something cool, it was to dive deep into systems programming (shaders, GPU memory) within a web context, thereby sharpening skills that are directly applicable to high-performance backend work (like understanding memory layouts, parallelism, and low-level debugging). The integration of a GraphQL API and handling real data shows a practical bent: this site stays up-to-date automatically, reducing manual upkeep; a sign of *engineering efficiency*.

Moreover, Yus.rs underscores maintainability and longevity. Using Rust means the project will compile and run years from now as reliably as today, and the codebase remains understandable and clean due to Rust’s emphasis on clarity and explicitness. The project’s structure, documentation, and code quality mirror what you’d expect in a collaborative professional environment, indicating that the author writes code ready for production and team contexts.

## Conclusion – A Passion for Excellence in Systems Engineering

Yus.rs is more than just a personal website; it’s a statement about the developer’s passion for systems-level thinking applied to real-world applications. Every layer of this project, from the GPU acceleration in the browser, to the asynchronous web server, down to the automated deployment , was built with a focus on **quality, performance, and reliability**. This aligns directly with what forward-thinking engineering teams seek in backend and systems roles.

By creating Yus.rs, the developer has demonstrated an ability to **deliver end-to-end solutions** with polish and precision. It’s a polished project that runs like a professional product, reflecting an engineering mindset that values doing things right. For a hiring manager evaluating Yus.rs, it should be clear that its creator approaches problems with curiosity, mastery of appropriate tools, and a determination to produce work that stands out. This same drive and attention to detail are exactly what the developer is excited to bring to a professional team; building reliable systems, pushing performance boundaries, and crafting software that makes an impact.
